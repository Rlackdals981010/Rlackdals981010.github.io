---
title: JPA 개인 프로젝트 - 업그레이드 캘린더
layout: post
permalink: /project/3
---

[프로젝트 Git Hub 링크](https://github.com/Rlackdals981010/SpringJpaCalender)

개발 기간 : 2024-08-21 ~ 진행중

---
<details>
<summary>8월 21일 수</summary>
<div markdown="1">

---
오늘은 ERD 수정을 시작으로
1. 일정 CRU
2. 댓글 CRUD
3. 일정 전체 출력 페이징
4. 일정 D
5. 유저 CRUD
까지 진행했다.

---
# ERD
ERD 작성부터 큰 고난이 있었다.
지금 진행되는 프로젝트는 2개 이상의 테이블이 서로 1:N 혹은 N:M 관계를 맺게 되어있다.
우선 처음 발생한 오류는 1:N 상황에서 1인 테이블에 외래키를 설정한것. -> N의 입장인 테이블에 설정해야한다.
지금 프로젝트를 예로 들면 1개의 Event에 N개의 댓글이 달린다. 그러면 댓글 table에 Event ID라는 FK를 만들어줘야 한다.

두번째 오류는 N:M을 바로 연관한것이다. 무조건 중간 테이블을 생성해서 1:N, 1:M 관계로 관리해야한다.
어차피 JPA도 중간 테이블을 임의로 만들어서 관리하기 때문에, 개발자가 직접 하는게 더 좋다.

무튼 ERD는 [ReadMe](https://github.com/Rlackdals981010/SpringJpaCalender)에 있다.

---

---
# 일정 CRU
---
기본적으로 모든 구현은 3 Layer architecture로 구성된다.
우선 JPA를 사용하기 때문에 JDBC를 사용한 전 프로젝트와는 달리
build.gradle에 implementation 'org.springframework.boot:spring-boot-starter-data-jpa'를 사용해주면 된다.
이후 Repository를 interface로 생성하고 expends JpaRepository<엔티티 타입, 키 타입>으로 만들고 사용하면 된다.
CRUD중 Update를 제외한 모든 구현이 JpaRepository내부에 되어있기 때문에 CRD는 구현이 JDBC때랑 똑같다.

JPA덕분에 모든 비즈니스 로직은 Service에서 이뤄지게 되었고, save, delete, findById 등등은 내장 메소드를 사용하면 된다.
단, Update는 구현되어있지 않기 때문에 조금 다르게 접근해야한다.
우선 Update메소드를 Entity 내부 메소드로 생성하고, 이용하면 되는데, 이때 @Transactional을 사용해야한다.
이 어노테이션을 사용하면 해당 메소드가 하나의 트랜잭션으로 취급되어 메소드 종료시 데이터베이스에 변경으로 커밋된다.
즉, 변경 대상 Event의 id를 통해서 해당 인스턴스에 접근하여 update()하고 종료하면 자동으로 데이터베이스에 업로드된다.

---
# 댓글 CRUD
---
댓글로 일정과 동일하게 동작하지만 지금까지의 엔티티들과 다르게, 댓글은 일정의 id를 외래키로 소지하고 있다.
또한 본 프로젝트의 엔티티는 전부 양방향 관계 이므로 일정이 존재해야지만 댓글을 생성할 수 있고, 댓글이 삭제되면 일정에서도 삭제되어야 한다.
하지만 일정 테이블에 댓글 관련 column이 없다. 이 경우 Event 엔티티 내부에 

{% highlight ruby %}
@OneToMany(mappedBy = "event")
private List<Comment> commentList = new ArrayList<>();
{% endhighlight %}

를 통해서  일정 엔티티가 댓글 엔티티를 가지고 있다는걸 알려야한다. 이래야지 1개의 일정에 여러 댓글이 있다는걸 JVM이 알 수 있기 때문

또한 사실 댓글이 삭제되어도 일정에는 영향이 없기 때문에 댓글 CRUD도 하던대로 하면 된다.

---
# 일정 전체 출력 페이징
---
페이징부터 JPA의 진가가 발휘된다.
페이징은 Spring Data JPA가 제공하는 Pageable과 Page인터페이스를 사용하면 된다.
우선 페이징을 위해선 필수적으로 표시할 페이지와 페이지당 포함한 데이터 개수를 알려줘야 한다.
본 프로젝트에서는 이러한 정보를 쿼리 파라미터로 받기 때문에 다음과 같이 받는다.

{% highlight ruby %}
    @GetMapping()
    public List<PageResponseDto> printEvents(
            @RequestParam(value = "page") Integer page,
            @RequestParam(value = "size", defaultValue = "10") Integer size) {
        return eventSerivce.printEvents(page, size);
    }
{% endhighlight %}
이를 통해 Service에서 페이지네이션을 진행한다.
{% highlight ruby %}
public List<PageResponseDto> printEvents(int page, int size) {
    Pageable pageable = PageRequest.of(page, size, Sort.by("modifiedAt").descending());
    return eventRepository.findAll(pageable)
        .map(event -> new PageResponseDto(
            event.getTitle(),
            event.getContent(),
            event.getCommentList().size(),
            event.getCreatedAt(),
            event.getModifiedAt(),
            event.getUsername()
        ))
        .getContent();
    }
{% endhighlight %}
위 코드를 보면 Pageable pageable = PageRequest.of(page, size, Sort.by("modifiedAt").descending()); 부분부터 보이는데,
Pageable은 JPA에서 제공하는 인터페이스이고, page, size, 정렬 순서 등을 매개변수로 넣을 수 있다. 즉, 나는 지금 어느 페이지를 보여달라고 요청중인데, 한 페이지당 size만큼의 일정이 수록되고, 수정일 기준으로 내림차순 해달라는 것이다.
이후 pageable 조건에 맞춰서 eventRepository에서 일정을 찾는데, 이때 요구사항에 따라 .map()으로 해당 데이터들을 넣어서 .getContent()를 통해 List로 반환하고 있다.

---
# 일정 D
---
일정 삭제는 List<Comment>를 통해서 댓글이 일정에 묶여있기 때문에 일정 삭제시 관련 댓글도 전부 삭제해야한다.
이때 사용하는것이 영속성 전이이다.
영속성 전이는 영속 상태의 Entity에 취해지는 작업이 관련 Entity 까지 전파되는 것이다.
영속성 전이로는 저장과 삭제가 수행될 수 있는데, 여기선 삭제만 구현한다.

{% highlight ruby %}
@OneToMany(mappedBy = "event", cascade = {CascadeType.PERSIST, CascadeType.REMOVE})//영속성 전이로 한번에 댓글 다 삭제
private List<Comment> commentList = new ArrayList<>();
{% endhighlight %}

@관계 어노테이션의 파라미터인 cascade로 지정이 가능한데, CascadeType.PERSIST가 영속 상태를 의미하고 CascadeType.REMOVE로 삭제시 영속성 전이된다는걸 알린다.
이렇게 설정하면 Service단에서는 그냥 repository.delete(event)로 해당 이벤트를 지우면 자동으로 댓글까지 다 삭제된다.

---
# 유저 CRUD
---
유저 테이블이 추가되는 부분이다. 이때부터 슬슬 관계들이 복잡해진다.
ERD를 보면 유저는 일정과의 중간테이블과 댓글과 연관이 있다. 이때, 한명의 유저가 댓글을 여러개 작성하고, 한명의 유저가 여러개의 일정을 작성(애매함)하는걸 보면 D의 경우 영속성 전이를 사용해야한다는걸 유추할 수 있다.
무튼 이걸 신경써서 CRUD를 구현하면 눈물나는 중간 테이블을 이용해 일정과 매칭하기 가 있다.

한명의 유저가 여러개의 일정을 작성.. 에서 애매하다고 했던 이유는, 일정을 작성한 유저는 추가로 일정 담당 유저를 배치할 수 있다는 요구사항이 있기 때문이다. 이때문에 일정과 유저는 N:M관계가 되고, 이는 곧 중간 테이블 생성을 요구하게 된다.
나의 경우 유저가 일정을 포스트 한다고 생각해서 Post 테이블을 생성했고, Post 테이블은 PK인 PostId와 FK인 UserId, EventId를 갖는다.

이 테이블을 이용해서 연관관계를 맺는건 다음과 같다.
{% highlight ruby %}
public void setUserToEvent(Long eventId, Long userId) {
    Event setEvent = findEvent(eventId);
    User setUser = userRepository.findById(userId).orElseThrow(() -> new IllegalArgumentException("해당 유저는 없습니다."));

    Post post = new Post();
    post.setEvent(setEvent);
    post.setUser(setUser);
    postRepository.save(post);
}
{% endhighlight %}

이렇게 설정할 Event와 User를 찾아서 Post에 넣으면 끝이다. 

---
이렇게 정리하다 보니까 좀 아쉬운게 많이 보이는데, 프로젝트 마감이 다음주 목요일이기 때문에 우선 남은 추가 요구사항을 구현하고, 리팩토링을 진행할 예정이다.
우선 지금 아쉬운건 event 생성시 존재하지 않는 user id를 넣어도 생성이 된다는점. 
User - Event 관계를 수동으로 맺어야한다는 점. 등등 이 있다. 

---
</div>
</details>
---
