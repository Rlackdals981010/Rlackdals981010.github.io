---
title: Spring - Entity N:1
layout: page
permalink:  /be/spring/entity/n1
---

{% highlight ruby %}
@ManyToOne
{% endhighlight %}
@ManyToOne 어노테이션은 N:1 관계를 맺어준다.

<details>
<summary>단방향</summary>
<div markdown="1">

---
@OneToOne을 @ManyToOne로 수정하면 1:1 관계와 동일한 형태로 사용한다.

---
</div>
</details>

<details>
<summary>양방향</summary>
<div markdown="1">

---
{% highlight ruby %}
@Entity
@Table(name = "food")
public class Food {
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private double price;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
}
{% endhighlight %}
///////////////////////////
{% highlight ruby %}
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @OneToMany(mappedBy = "user")
    private List<Food> foodList = new ArrayList<>();

    public void addFoodList(Food food) {
        this.foodList.add(food);
        food.setUser(this); // 외래 키(연관 관계) 설정
    }
}
{% endhighlight %}
외래 키의 주인 Entity는 사실상 1:1과 동일하지만, 비주인 Entity는 private Food food;던 형태에서
private List<Food> foodList = new ArrayList<>();로 리스트 형태로 변했다.

이게 바로 N:1 관계이기 때문인데, 외래 키의 주인을 여러번 참조하기 때문에 리스트 형태로 받는것이다.
이후 이 List는 자바 내에서 사용되기 때문에 메소드로 기능을 구현해서 사용한다.
{% highlight ruby %}
User user = new User();
user.setName("Robbie");
user.addFoodList(food);
user.addFoodList(food2);
{% endhighlight %}
이 코드를 통해 List에 저장하고, 추후 get메소드를 통해 해당 리스트를 받고 for문으로 출력을 진행하면 된다.


---
</div>
</details>
