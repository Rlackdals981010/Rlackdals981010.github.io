---
title: 디자인패턴
layout: page
permalink: /cs/design-pattern
---
> 프로그램 설계시 발생한 문제점들을 객체간 상호 관계를 이용해 해결할 수 있도록 하나의 규약으로 만들어 둔것.

# 싱글톤 패턴
---
> 하나의 클래스에 오직 하나의 인스턴스만!
 
원래 하나의 클래스로 무한대의 인스턴스를 만들 수 있다. (클래스는 설계도니까.)
하지만 그렇게 하지 않고, 하나의 클래스를 기반으론 하나의 인스턴스만 만들어 이를 기반으로 로직을 만드는 패턴이다.
보통 DB 연결 모듈에 많이 사용하고, Spring도 그렇다(고 알고있다. Prototype 제외하면..).

하나의 인스턴스를 만들고 해당 인스턴스를 여러 모듈이 공유하며 사용하게 된다. 
인스턴스 생성을 하나만 하니 비용은 줄지만, 의존성이 높아지는 단점이 있다.

또한 싱글톤 패턴은 TDD(Test Driven Development)시 단점이 된다.
TDD는 보통 단위 테스트를 하는데, 단위 테스트는 테스트 끼리 서로 독집적인 테스트이다.
하지만, 싱글톤은 하나의 인스턴스를 공유하니까 TDD가 쉽지 않다.

위에 서술한 여러 단점중 가장 핵심이 의존성이 높다는 것이다.
이를 해결하기 위해서 DI가 필수라고 볼 수 있다.

# 팩토리 패턴
---
> 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴
 
상속 관계인 두 클래스에서 상위가 뼈대, 하위 애서 객체 생성 관련 내용을 구체화하는 패턴이다.

상위-하위 클래스가 분리되기 때문에 느슨한 결합을 갖게되며, 상위 클래스는 인스턴스 생성과 관련이 없기 때문에 매우매우 유연하다.
그리고 객체 생성 로직이 따로 분리되어있기 때문에 리팩토링을 진행해도 한 곳만 고치면 된다.

예를들어 상위 클래스는 커피공장이고 하위 클래스는 라떼 레시피, 아아 레시피 등등 구체적 레시피가 있다. 상위 클래스는 그냥 들어오는 레시피를 토대로 음료만 찍으면 된다.

# 전략 패턴
---
> 객체의 행위를 바꾸고 싶은 경우 캡슐화한 알고리즘을 컨텍스트 안에서 바꿔주면서 상호 교체하는 패턴
 
정책 패턴이라고도 불리는 이 패턴은 객체의 행위를 직접 수정하지 않는다. 그저 갈아 끼울뿐
결제라는 행위를 할때 네이버 페이, 카카오 페이, 카드 결제등 여러 방법으로 결제하듯 전략만 바꾸는거다.

# 옵저버 패턴
---
> 주체가 어떤 객체(Subject)의 상태 변화를 관찰하다가, 변화 발생시 옵저버들에게 변화를 알리는 패턴

여기서 주체는 객체의 상태 변화를 보는 관찰자이며,
옵저버는 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 추가 변경 사항이 생기는 객체들 이다.

트위터가 옵저버 패턴을 활용한 서비스다.
내가 어떤 사람인 주체를 팔로우 했다면, 주체가 포스팅시 알림이 팔로워에게 간다.

또한 주로 이벤트 패턴에 사용되는 이 패턴은 MVC에서도 사용된다.
Model에서 변경 발생시 update 메서드로 옵저버(View)에게 알려주고, 이를 기반으로 Controller가 작동되는 방식이다.

# 프록시 패턴과 프록시 서버
---
> 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 패턴

먼저 프록시 객체는 다음과 같다.
어떠한 대상의 기본적 동작(속성 접근, 할당, 순회, 열거, 함수 호출..)등 작업을 가로챌 수 있는 객체

프록시 서버는 다음과 같다.
서버와 클라이언트 사이에서 클라이언트가 자신ㄴ을 통해 다른 네트워크 서비스에 간접적으로 접속하게 해주는 시스템이나 프로그램

Q. 그렇다면, 로깅 및 보안 처리에 활용되고, 인증/인가를 처리하는 필터가 프록시 객체인가?
A. 이건 아니다. 프록시 패턴은 주로 객체 접근을 제어하는데 사용하고, 필터는 요청이나 응답을 변형하거나 전처리하는것에 목직이 있다.

# 이터레이터 패턴
---
> Iterator를 사용해서 컬렉션의 요소들에 접근하는 패턴

자료형의 구조와는 상관없이 이터레이터라는 인터페이스로 순회가 가능하다.

# 노출모듈 패턴
---
> 즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴

# MVC 패턴
---
> Model, View, Controller로 이뤄진 디자인 패턴
 
Model
데이터베이스, 상수, 변수와 같은 데이터와 비즈니스 로직을 담당한다.
데이터를 저장하고 관리하며, 상태 변경에 대한 처리르 수행한다.

View
사용자에게 정보를 표시하는 UI를 구성한다.
모델에서 데이터를 가져와 사용자에게 보여준다.

Controller
사용자 입력을 처리하고, 모델과 뷰 사이의 상호작용을 조정한다.
사용자가 인터페이스와 상호작용시 Controller가 이를 처리하고, 적절한 모델을 업데이트 해서 View를 갱신한다.

# MVP 패턴
---
> MVC에서 Controller가 Presenter로 변경되었다.

뷰와 프레젠터는 1:1 관계라서 MVC보다 더 강한 결합의 패턴이라고 보면 된다.

# MVVM 패턴
---
> MVVM 패턴은 MVC의 C에 해당하는 컨트롤러가 View Model로 바뀐 패턴

뷰 모델을 뷰를 더 추상화한 계층이다.
MVVM은 MVC와 다르게 커맨드와 데이터 바인딩을 갖는다.
뷰와 뷰모델 사이 양방향 데이터 바인딩을 지원하며, UI를 코드 수정 없이 재사용하고, 단위 테스팅이 쉬운 장점이 있다.